/*        Generated by TAPENADE     (INRIA, Ecuador team)
    Tapenade 3.12 (r6213) - 13 Oct 2016 10:54
*/
#include "DIFFSIZES.inc"
/*  Hint: NBDirsMax should be the maximum number of differentiation directions
*/

/*
  Differentiation of get_HLL_flux in forward (tangent) mode:
   variations   of useful results: *flux
   with respect to varying inputs: *ul *ur
   RW status of diff variables: *flux:out *ul:in *ur:in
   Plus diff mem management of: flux:in ul:in ur:in
*/
void get_HLL_flux_dv(const const double *ul, double (*uld)[NBDirsMax], const 
        const double *ur, double (*urd)[NBDirsMax], const const double *n, 
        const double *flux, double (*fluxd)[NBDirsMax], int nbdirs) {
    const double g = 1.4;
    double Hi, Hj, ci, cj, pi, pj, vxi, vxj, vyi, vyj, vmag2i, vmag2j, vni, 
    vnj;
    double Hid[NBDirsMax], Hjd[NBDirsMax], cid[NBDirsMax], cjd[NBDirsMax], pid
    [NBDirsMax], pjd[NBDirsMax], vxid[NBDirsMax], vxjd[NBDirsMax], vyid[
    NBDirsMax], vyjd[NBDirsMax], vmag2id[NBDirsMax], vmag2jd[NBDirsMax], vnid[
    NBDirsMax], vnjd[NBDirsMax];
    double fabs0;
    double fabs0d[NBDirsMax];
    double fabs1;
    double fabs1d[NBDirsMax];
    double arg1;
    double arg1d[NBDirsMax];
    int nd;
    vxi = ul[1]/ul[0];
    vyi = ul[2]/ul[0];
    vxj = ur[1]/ur[0];
    vyj = ur[2]/ur[0];
    vmag2i = vxi*vxi + vyi*vyi;
    vmag2j = vxj*vxj + vyj*vyj;
    pi = (g-1.0)*(ul[3]-0.5*ul[0]*vmag2i);
    pj = (g-1.0)*(ur[3]-0.5*ur[0]*vmag2j);
    arg1 = g*pi/ul[0];
    for (nd = 0; nd < nbdirs; ++nd) {
        vxid[nd] = (uld[1][nd]*ul[0]-ul[1]*uld[0][nd])/(ul[0]*ul[0]);
        vyid[nd] = (uld[2][nd]*ul[0]-ul[2]*uld[0][nd])/(ul[0]*ul[0]);
        vxjd[nd] = (urd[1][nd]*ur[0]-ur[1]*urd[0][nd])/(ur[0]*ur[0]);
        vyjd[nd] = (urd[2][nd]*ur[0]-ur[2]*urd[0][nd])/(ur[0]*ur[0]);
        vnid[nd] = n[0]*vxid[nd] + n[1]*vyid[nd];
        vnjd[nd] = n[0]*vxjd[nd] + n[1]*vyjd[nd];
        vmag2id[nd] = vxid[nd]*vxi + vxi*vxid[nd] + vyid[nd]*vyi + vyi*vyid[nd
            ];
        vmag2jd[nd] = vxjd[nd]*vxj + vxj*vxjd[nd] + vyjd[nd]*vyj + vyj*vyjd[nd
            ];
        // pressures
        pid[nd] = (g-1.0)*(uld[3][nd]-0.5*(uld[0][nd]*vmag2i+ul[0]*vmag2id[nd]
            ));
        pjd[nd] = (g-1.0)*(urd[3][nd]-0.5*(urd[0][nd]*vmag2j+ur[0]*vmag2jd[nd]
            ));
        // speeds of sound
        arg1d[nd] = (g*pid[nd]*ul[0]-g*pi*uld[0][nd])/(ul[0]*ul[0]);
        cid[nd] = (arg1 == 0.0 ? 0.0 : arg1d[nd]/(2.0*sqrt(arg1)));
        arg1d[nd] = (g*pjd[nd]*ur[0]-g*pj*urd[0][nd])/(ur[0]*ur[0]);
        // enthalpies (E + p/rho = u(3)/u(0) + p/u(0) (actually specific enthalpy := enthalpy per unit mass)
        Hid[nd] = ((uld[3][nd]+pid[nd])*ul[0]-(ul[3]+pi)*uld[0][nd])/(ul[0]*ul
            [0]);
        Hjd[nd] = ((urd[3][nd]+pjd[nd])*ur[0]-(ur[3]+pj)*urd[0][nd])/(ur[0]*ur
            [0]);
        sld[nd] = vnid[nd] - cid[nd];
    }
    vni = vxi*n[0] + vyi*n[1];
    vnj = vxj*n[0] + vyj*n[1];
    ci = sqrt(arg1);
    arg1 = g*pj/ur[0];
    for (nd = 0; nd < nbdirs; ++nd) {
        cjd[nd] = (arg1 == 0.0 ? 0.0 : arg1d[nd]/(2.0*sqrt(arg1)));
        arg1d[nd] = (urd[0][nd]*ul[0]-ur[0]*uld[0][nd])/(ul[0]*ul[0]);
    }
    cj = sqrt(arg1);
    Hi = (ul[3]+pi)/ul[0];
    Hj = (ur[3]+pj)/ur[0];
    // compute Roe-averages
    double Rij, vxij, vyij, Hij, cij, vm2ij, vnij;
    double Rijd[NBDirsMax], vxijd[NBDirsMax], vyijd[NBDirsMax], Hijd[NBDirsMax
    ], cijd[NBDirsMax], vm2ijd[NBDirsMax], vnijd[NBDirsMax];
    arg1 = ur[0]/ul[0];
    Rij = sqrt(arg1);
    vxij = (Rij*vxj+vxi)/(Rij+1.0);
    vyij = (Rij*vyj+vyi)/(Rij+1.0);
    for (nd = 0; nd < nbdirs; ++nd) {
        Rijd[nd] = (arg1 == 0.0 ? 0.0 : arg1d[nd]/(2.0*sqrt(arg1)));
        vxijd[nd] = ((Rijd[nd]*vxj+Rij*vxjd[nd]+vxid[nd])*(Rij+1.0)-(Rij*vxj+
            vxi)*Rijd[nd])/((Rij+1.0)*(Rij+1.0));
        vyijd[nd] = ((Rijd[nd]*vyj+Rij*vyjd[nd]+vyid[nd])*(Rij+1.0)-(Rij*vyj+
            vyi)*Rijd[nd])/((Rij+1.0)*(Rij+1.0));
        Hijd[nd] = ((Rijd[nd]*Hj+Rij*Hjd[nd]+Hid[nd])*(Rij+1.0)-(Rij*Hj+Hi)*
            Rijd[nd])/((Rij+1.0)*(Rij+1.0));
        vm2ijd[nd] = vxijd[nd]*vxij + vxij*vxijd[nd] + vyijd[nd]*vyij + vyij*
            vyijd[nd];
        vnijd[nd] = n[0]*vxijd[nd] + n[1]*vyijd[nd];
        arg1d[nd] = (g-1.0)*(Hijd[nd]-0.5*vm2ijd[nd]);
    }
    Hij = (Rij*Hj+Hi)/(Rij+1.0);
    vm2ij = vxij*vxij + vyij*vyij;
    vnij = vxij*n[0] + vyij*n[1];
    arg1 = (g-1.0)*(Hij-vm2ij*0.5);
    for (nd = 0; nd < nbdirs; ++nd)
        cijd[nd] = (arg1 == 0.0 ? 0.0 : arg1d[nd]/(2.0*sqrt(arg1)));
    cij = sqrt(arg1);
    // Einfeldt estimate for signal speeds
    double sr, sl, sr0, sl0;
    double srd[NBDirsMax], sld[NBDirsMax], sr0d[NBDirsMax], sl0d[NBDirsMax];
    sl = vni - ci;
    if (sl > vnij - cij) {
        for (nd = 0; nd < nbdirs; ++nd)
            sld[nd] = vnijd[nd] - cijd[nd];
        sl = vnij - cij;
    }
    for (nd = 0; nd < nbdirs; ++nd)
        srd[nd] = vnjd[nd] + cjd[nd];
    sr = vnj + cj;
    if (sr < vnij + cij) {
        for (nd = 0; nd < nbdirs; ++nd)
            srd[nd] = vnijd[nd] + cijd[nd];
        sr = vnij + cij;
    }
    if (sr > 0) {
        sr0 = 0;
        for (nd = 0; nd < nbdirs; ++nd)
            sr0d[nd] = 0.0;
    } else {
        for (nd = 0; nd < nbdirs; ++nd)
            sr0d[nd] = srd[nd];
        sr0 = sr;
    }
    if (sl > 0) {
        sl0 = 0;
        for (nd = 0; nd < nbdirs; ++nd)
            sl0d[nd] = 0.0;
    } else {
        for (nd = 0; nd < nbdirs; ++nd)
            sl0d[nd] = sld[nd];
        sl0 = sl;
    }
    // flux
    double t1, t2, t3;
    double t1d[NBDirsMax], t2d[NBDirsMax], t3d[NBDirsMax];
    for (nd = 0; nd < nbdirs; ++nd) {
        t1d[nd] = ((sr0d[nd]-sl0d[nd])*(sr-sl)-(sr0-sl0)*(srd[nd]-sld[nd]))/((
            sr-sl)*(sr-sl));
        t2d[nd] = -t1d[nd];
    }
    t1 = (sr0-sl0)/(sr-sl);
    t2 = 1.0 - t1;
    if (sl >= 0.0) {
        for (nd = 0; nd < nbdirs; ++nd)
            fabs0d[nd] = sld[nd];
        fabs0 = sl;
    } else {
        for (nd = 0; nd < nbdirs; ++nd)
            fabs0d[nd] = -sld[nd];
        fabs0 = -sl;
    }
    if (sr >= 0.0) {
        for (nd = 0; nd < nbdirs; ++nd)
            fabs1d[nd] = srd[nd];
        fabs1 = sr;
    } else {
        for (nd = 0; nd < nbdirs; ++nd)
            fabs1d[nd] = -srd[nd];
        fabs1 = -sr;
    }
    t3 = 0.5*(sr*fabs0-sl*fabs1)/(sr-sl);
    for (nd = 0; nd < nbdirs; ++nd) {
        t3d[nd] = (0.5*(srd[nd]*fabs0+sr*fabs0d[nd]-sld[nd]*fabs1-sl*fabs1d[nd
            ])*(sr-sl)-0.5*(sr*fabs0-sl*fabs1)*(srd[nd]-sld[nd]))/((sr-sl)*(sr
            -sl));
        fluxd[0][nd] = (t1d[nd]*vnj+t1*vnjd[nd])*ur[0] + t1*vnj*urd[0][nd] + (
            t2d[nd]*vni+t2*vnid[nd])*ul[0] + t2*vni*uld[0][nd] - t3d[nd]*(ur[0
            ]-ul[0]) - t3*(urd[0][nd]-uld[0][nd]);
    }
    flux[0] = t1*vnj*ur[0] + t2*vni*ul[0] - t3*(ur[0]-ul[0]);
    for (nd = 0; nd < nbdirs; ++nd)
        fluxd[1][nd] = t1d[nd]*(vnj*ur[1]+pj*n[0]) + t1*(vnjd[nd]*ur[1]+vnj*
            urd[1][nd]+n[0]*pjd[nd]) + t2d[nd]*(vni*ul[1]+pi*n[0]) + t2*(vnid[
            nd]*ul[1]+vni*uld[1][nd]+n[0]*pid[nd]) - t3d[nd]*(ur[1]-ul[1]) - 
            t3*(urd[1][nd]-uld[1][nd]);
    flux[1] = t1*(vnj*ur[1]+pj*n[0]) + t2*(vni*ul[1]+pi*n[0]) - t3*(ur[1]-ul[1
        ]);
    for (nd = 0; nd < nbdirs; ++nd)
        fluxd[2][nd] = t1d[nd]*(vnj*ur[2]+pj*n[1]) + t1*(vnjd[nd]*ur[2]+vnj*
            urd[2][nd]+n[1]*pjd[nd]) + t2d[nd]*(vni*ul[2]+pi*n[1]) + t2*(vnid[
            nd]*ul[2]+vni*uld[2][nd]+n[1]*pid[nd]) - t3d[nd]*(ur[2]-ul[2]) - 
            t3*(urd[2][nd]-uld[2][nd]);
    flux[2] = t1*(vnj*ur[2]+pj*n[1]) + t2*(vni*ul[2]+pi*n[1]) - t3*(ur[2]-ul[2
        ]);
    for (nd = 0; nd < nbdirs; ++nd)
        fluxd[3][nd] = (t1d[nd]*vnj+t1*vnjd[nd])*ur[0]*Hj + t1*vnj*(urd[0][nd]
            *Hj+ur[0]*Hjd[nd]) + (t2d[nd]*vni+t2*vnid[nd])*ul[0]*Hi + t2*vni*(
            uld[0][nd]*Hi+ul[0]*Hid[nd]) - t3d[nd]*(ur[3]-ul[3]) - t3*(urd[3][
            nd]-uld[3][nd]);
    flux[3] = t1*(vnj*ur[0]*Hj) + t2*(vni*ul[0]*Hi) - t3*(ur[3]-ul[3]);
}
